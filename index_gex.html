<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GEX HTML Archive Viewer</title>

  <style>
    :root {
      --bg0: #0b0f14;
      --bg1: #111826;
      --bg2: #182235;
      --text0: #e6edf3;
      --text1: #94a3b8;
      --border: rgba(148, 163, 184, 0.18);
      --accent: #4cc9f0;
      --accent2: #b5179e;
      --danger: #f87171;
      --ok: #34d399;
      --warn: #fbbf24;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --topbar-h: 48px;
      --sidebar-w: 260px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 20%, rgba(76, 201, 240, 0.10), transparent 55%),
                  radial-gradient(1200px 800px at 80% 80%, rgba(181, 23, 158, 0.08), transparent 55%),
                  var(--bg0);
      color: var(--text0);
      font-family: var(--sans);
      overflow: hidden;
    }

    .app {
      height: 100%;
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      gap: 10px;
      padding: 10px;
      min-height: 0;
    }

    .sidebar {
      background: linear-gradient(180deg, rgba(17, 24, 38, 0.98), rgba(17, 24, 38, 0.92));
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-width: 200px;
      min-height: 0;
    }

    .sidebarHeader {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .title {
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.2px;
      line-height: 1.1;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .folderDisplay {
      font-size: 10px;
      color: var(--text1);
      font-family: var(--mono);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding: 4px 0;
    }
    .folderDisplay.hasFolder {
      color: var(--ok);
    }
    .folderDisplay.cached {
      color: var(--warn);
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.8);
      color: var(--text0);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 11px;
      cursor: pointer;
      transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease;
      user-select: none;
    }
    .btn:hover { border-color: rgba(76, 201, 240, 0.45); transform: translateY(-1px); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .btnPrimary {
      border-color: rgba(76, 201, 240, 0.40);
      background: linear-gradient(135deg, rgba(76, 201, 240, 0.22), rgba(181, 23, 158, 0.14));
    }
    .btnSmall {
      padding: 4px 6px;
      font-size: 10px;
    }

    .btnTicker {
      padding: 3px 8px;
      font-size: 10px;
      font-family: var(--mono);
      border-radius: 12px;
      background: rgba(24, 34, 53, 0.6);
      border: 1px solid var(--border);
      color: var(--text0);
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .btnTicker:hover {
      border-color: var(--accent);
      background: rgba(76, 201, 240, 0.15);
    }
    .btnTicker.active {
      border-color: var(--accent);
      background: rgba(76, 201, 240, 0.25);
      color: var(--accent);
    }
    .btnTicker.unavailable {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .btnTicker.unavailable:hover {
      border-color: var(--border);
      background: rgba(24, 34, 53, 0.6);
    }

    .controls {
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    label {
      font-size: 10px;
      color: var(--text1);
    }

    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.65);
      color: var(--text0);
      font-size: 11px;
      font-family: var(--mono);
      outline: none;
    }
    select:focus {
      border-color: rgba(76, 201, 240, 0.55);
      box-shadow: 0 0 0 3px rgba(76, 201, 240, 0.12);
    }

    .recentTickers {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 2px;
    }
    .recentTickersLabel {
      font-size: 9px;
      color: var(--text1);
      width: 100%;
      margin-bottom: 2px;
    }

    .main {
      background: linear-gradient(180deg, rgba(17, 24, 38, 0.92), rgba(17, 24, 38, 0.78));
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      grid-template-rows: var(--topbar-h) 1fr;
      min-width: 320px;
      min-height: 0;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.35);
    }

    .status {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text1);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }

    .actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .viewer {
      min-height: 0;
      background: rgba(11, 15, 20, 0.35);
      position: relative;
    }

    .loadingOverlay {
      position: absolute;
      inset: 0;
      background: rgba(11, 15, 20, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s ease;
    }
    .loadingOverlay.show {
      opacity: 1;
      pointer-events: auto;
    }
    .loadingOverlay span {
      font-family: var(--mono);
      font-size: 14px;
      color: var(--accent);
    }

    iframe {
      width: 100%;
      height: 100%;
      border: 0;
      background: #ffffff;
    }

    .hint {
      font-family: var(--mono);
      font-size: 10px;
      color: var(--text1);
      line-height: 1.4;
      padding: 6px 0;
      border-bottom: 1px solid var(--border);
      margin-bottom: 4px;
    }
    .hint kbd {
      font-family: var(--mono);
      font-size: 9px;
      padding: 1px 4px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.55);
      color: var(--text0);
    }

    .progressBar {
      height: 3px;
      background: var(--bg2);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 4px;
    }
    .progressBar .fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      width: 0%;
      transition: width 0.1s ease;
    }

    .infoBox {
      background: rgba(24, 34, 53, 0.5);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      font-family: var(--mono);
      font-size: 10px;
      color: var(--text1);
      display: grid;
      gap: 2px;
    }
    .infoBox .label { color: var(--text1); }
    .infoBox .value { color: var(--text0); margin-left: 4px; }

    .cacheNote {
      font-size: 9px;
      color: var(--warn);
      padding: 4px 8px;
      background: rgba(251, 191, 36, 0.1);
      border-radius: 6px;
      border: 1px solid rgba(251, 191, 36, 0.2);
    }

    /* collapsed sidebar */
    body.sidebarCollapsed .app { grid-template-columns: 1fr; }
    body.sidebarCollapsed .sidebar { display: none; }
    body.sidebarCollapsed .main { min-width: 0; }

    @media (max-width: 800px) {
      .app { grid-template-columns: 1fr; }
      .sidebar { order: 2; min-width: 0; }
      .main { order: 1; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <div class="sidebarHeader">
        <div class="title">GEX Archive Viewer</div>
        <button class="btn btnSmall" id="collapseBtn" title="æ”¶åˆå´æ¬„">æ”¶åˆ</button>
      </div>

      <div class="controls">
        <input id="dirInput" type="file" webkitdirectory multiple style="display:none" />

        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <button class="btn btnPrimary" id="authorizeBtn" style="display:none;">æˆæ¬Šå­˜å–</button>
          <button class="btn" id="pickFolderBtn">é¸æ“‡è³‡æ–™å¤¾</button>
          <button class="btn" id="rescanBtn" title="é‡æ–°æƒæè³‡æ–™å¤¾ä»¥è¼‰å…¥æ–°å¢çš„æª”æ¡ˆ" style="display:none;">é‡æ–°æƒææ–°å¢æª”æ¡ˆ</button>
        </div>
        <div class="folderDisplay" id="folderLabel">å°šæœªé¸æ“‡è³‡æ–™å¤¾</div>
        <div style="font-size:9px; color:var(--text1); margin-top:2px;">
          ğŸ’¡ æœ¬æ©Ÿ HTML ç¨‹å¼ï¼Œä¸æœƒè¤‡è£½æˆ–ä¸Šå‚³æª”æ¡ˆï¼Œä½†éœ€æˆæ¬Šè®€å–
        </div>
        <div class="cacheNote" id="cacheNote" style="display:none;">
          ğŸ”’ éœ€æˆæ¬Šå­˜å–æ‰èƒ½ç€è¦½æª”æ¡ˆå…§å®¹
        </div>

        <div id="scanProgress" style="display:none;">
          <div style="font-size:10px; color:var(--text1);" id="scanProgressText">æƒæä¸­...</div>
          <div class="progressBar"><div class="fill" id="scanProgressFill"></div></div>
        </div>

        <div class="field">
          <label for="tickerSel">Ticker</label>
          <select id="tickerSel"></select>
          <div class="recentTickers" id="recentTickers"></div>
        </div>

        <div class="row">
          <div class="field">
            <label for="dateSel">è·³åˆ°æ—¥æœŸ</label>
            <select id="dateSel"></select>
          </div>
          <div class="field">
            <label for="featureSel">è·³åˆ°åŠŸèƒ½</label>
            <select id="featureSel"></select>
          </div>
        </div>

        <div class="hint">
          <kbd>â†‘</kbd>/<kbd>â†“</kbd> ä¸Š/ä¸‹ä¸€å€‹ã€€<kbd>â†</kbd>/<kbd>â†’</kbd> åˆ‡æ›åŠŸèƒ½
        </div>

        <div class="infoBox" id="currentInfo" style="display:none;">
          <div><span class="label">ç›®å‰ï¼š</span><span class="value" id="infoDate">-</span></div>
          <div><span class="label">åŠŸèƒ½ï¼š</span><span class="value" id="infoFeature">-</span></div>
          <div><span class="label">ä½ç½®ï¼š</span><span class="value" id="infoIndex">-</span></div>
        </div>
      </div>
    </aside>

    <main class="main" id="mainPanel">
      <div class="topbar">
        <div class="status" id="statusText">è«‹å…ˆæŒ‰ã€Œé¸æ“‡è³‡æ–™å¤¾ã€è¼‰å…¥ HTML å­˜æª”ã€‚</div>
        <div class="actions">
          <button class="btn btnSmall" id="toggleSidebarBtn" title="æ”¶åˆ/å±•é–‹å´æ¬„">æ”¶åˆå´æ¬„</button>
          <button class="btn btnSmall" id="openNewTabBtn" title="ç”¨æ–°åˆ†é é–‹å•Ÿç›®å‰æª”æ¡ˆ" disabled>æ–°åˆ†é </button>
          <button class="btn btnSmall" id="fullscreenBtn" title="å…¨è¢å¹•" disabled>å…¨è¢å¹•</button>
        </div>
      </div>
      <div class="viewer">
        <div class="loadingOverlay" id="loadingOverlay"><span>è¼‰å…¥ä¸­...</span></div>
        <iframe id="viewerFrame" title="HTML Viewer"></iframe>
      </div>
    </main>
  </div>

  <script>
    // -----------------------------
    // State
    // -----------------------------
    const state = {
      files: [],
      cachedRecords: [],
      displayRecords: [],
      filtered: [],
      activeIndex: -1,
      activeObjectUrl: null,
      newTabBlobUrl: null,
      folderDisplayName: "",
      lastDirHandle: null,
      tickerSelected: false,
      hasFolderSelected: false,
      recentTickers: [],
      usingCache: false,
      fileMap: new Map(),
    };

    const RECENT_TICKERS_KEY = 'gex_recent_tickers';
    const MAX_RECENT_TICKERS = 10;
    const IDB_NAME = 'gex_viewer';
    const IDB_VERSION = 2; // Bump version to add fileCache store
    const CACHE_STORE = 'fileCache';
    const KV_STORE = 'kv';

    // -----------------------------
    // DOM
    // -----------------------------
    const el = {
      dirInput: document.getElementById('dirInput'),
      authorizeBtn: document.getElementById('authorizeBtn'),
      pickFolderBtn: document.getElementById('pickFolderBtn'),
      rescanBtn: document.getElementById('rescanBtn'),
      folderLabel: document.getElementById('folderLabel'),
      cacheNote: document.getElementById('cacheNote'),
      dateSel: document.getElementById('dateSel'),
      tickerSel: document.getElementById('tickerSel'),
      featureSel: document.getElementById('featureSel'),
      viewerFrame: document.getElementById('viewerFrame'),
      statusText: document.getElementById('statusText'),
      collapseBtn: document.getElementById('collapseBtn'),
      toggleSidebarBtn: document.getElementById('toggleSidebarBtn'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      openNewTabBtn: document.getElementById('openNewTabBtn'),
      loadingOverlay: document.getElementById('loadingOverlay'),
      scanProgress: document.getElementById('scanProgress'),
      scanProgressText: document.getElementById('scanProgressText'),
      scanProgressFill: document.getElementById('scanProgressFill'),
      currentInfo: document.getElementById('currentInfo'),
      infoDate: document.getElementById('infoDate'),
      infoFeature: document.getElementById('infoFeature'),
      infoIndex: document.getElementById('infoIndex'),
      recentTickers: document.getElementById('recentTickers'),
    };

    // -----------------------------
    // Helpers
    // -----------------------------
    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function normalizeTime(raw) {
      return raw.replace(';', ':');
    }

    function parseRecordFromFileLike({ file, relPath, name }) {
      const m = name.match(/^(\d{4}-\d{2}-\d{2})_(\d{2}[;:]\d{2})_([A-Za-z0-9]+)_(.+)\.html$/i);
      if (!m) return null;

      const date = m[1];
      const time = normalizeTime(m[2]);
      const ticker = m[3].toUpperCase();
      const feature = m[4];
      const dt = new Date(`${date}T${time}:00`);
      const ts = Number.isFinite(dt.getTime()) ? dt.getTime() : null;
      if (ts === null) return null;

      return { file, relPath, name, date, time, ticker, feature, ts };
    }

    function parseRecordFromCache({ relPath, name, date, time, ticker, feature, ts }) {
      return { file: null, relPath, name, date, time, ticker, feature, ts };
    }

    function recordToCache(r) {
      return { relPath: r.relPath, name: r.name, date: r.date, time: r.time, ticker: r.ticker, feature: r.feature, ts: r.ts };
    }

    function setStatus(text, kind = "info") {
      const prefix = kind === "error" ? "âœ— " : kind === "ok" ? "âœ“ " : "â€¢ ";
      el.statusText.textContent = `${prefix}${text}`;
    }

    function updatePageTitle(record) {
      if (record) {
        document.title = `${record.ticker} ${record.date} ${record.time} ${record.feature} - GEX Viewer`;
      } else {
        document.title = 'GEX HTML Archive Viewer';
      }
    }

    function updateFolderDisplay() {
      if (state.usingCache && state.folderDisplayName) {
        // Has cache but not authorized yet
        el.folderLabel.textContent = `ğŸ“¦ ${state.folderDisplayName} (å¿«å–)`;
        el.folderLabel.classList.remove('hasFolder');
        el.folderLabel.classList.add('cached');
        el.authorizeBtn.style.display = 'inline-block';
        el.pickFolderBtn.textContent = 'æ›´æ”¹è³‡æ–™å¤¾';
        el.pickFolderBtn.style.display = 'inline-block';
        el.rescanBtn.style.display = 'none';
        el.cacheNote.style.display = 'block';
      } else if (state.hasFolderSelected && state.folderDisplayName) {
        // Has folder access (authorized)
        el.folderLabel.textContent = `ğŸ“ ${state.folderDisplayName}`;
        el.folderLabel.classList.add('hasFolder');
        el.folderLabel.classList.remove('cached');
        el.authorizeBtn.style.display = 'none';
        el.pickFolderBtn.textContent = 'æ›´æ”¹è³‡æ–™å¤¾';
        el.pickFolderBtn.style.display = 'inline-block';
        el.rescanBtn.style.display = 'inline-block';
        el.cacheNote.style.display = 'none';
      } else {
        // No cache, no folder
        el.folderLabel.textContent = 'å°šæœªé¸æ“‡è³‡æ–™å¤¾';
        el.folderLabel.classList.remove('hasFolder');
        el.folderLabel.classList.remove('cached');
        el.authorizeBtn.style.display = 'none';
        el.pickFolderBtn.textContent = 'é¸æ“‡è³‡æ–™å¤¾';
        el.pickFolderBtn.style.display = 'inline-block';
        el.rescanBtn.style.display = 'none';
        el.cacheNote.style.display = 'none';
      }
    }

    function fillSelect(selectEl, values, { placeholder = null } = {}) {
      const curr = selectEl.value;
      const opts = [];
      if (placeholder) opts.push({ value: "__PLACEHOLDER__", label: placeholder, disabled: true });
      for (const v of values) opts.push({ value: v, label: v });
      selectEl.innerHTML = opts.map(o => 
        `<option value="${escapeHtml(o.value)}" ${o.disabled ? 'disabled' : ''}>${escapeHtml(o.label)}</option>`
      ).join('');
      if (opts.some(o => o.value === curr && !o.disabled)) selectEl.value = curr;
      else if (placeholder) selectEl.value = "__PLACEHOLDER__";
      else selectEl.value = values[0] ?? "";
    }

    function getSelectedTicker() {
      const v = el.tickerSel.value;
      if (v === "__PLACEHOLDER__") return null;
      return v;
    }

    function getFilteredByTicker() {
      const ticker = getSelectedTicker();
      if (!ticker) return [];
      return state.displayRecords
        .filter(r => r.ticker === ticker)
        .sort((a, b) => b.ts - a.ts || a.relPath.localeCompare(b.relPath));
    }

    function isTypingContext() {
      const a = document.activeElement;
      if (!a) return false;
      const tag = a.tagName;
      return tag === 'INPUT' || tag === 'TEXTAREA' || a.isContentEditable;
    }

    function showLoading(show) {
      if (show) el.loadingOverlay.classList.add('show');
      else el.loadingOverlay.classList.remove('show');
    }


    // -----------------------------
    // IndexedDB (with fileCache store)
    // -----------------------------
    const idb = {
      db: null,
      async open() {
        if (this.db) return this.db;
        this.db = await new Promise((resolve, reject) => {
          const req = indexedDB.open(IDB_NAME, IDB_VERSION);
          req.onupgradeneeded = (e) => {
            const db = e.target.result;
            // KV store for directory handle
            if (!db.objectStoreNames.contains(KV_STORE)) {
              db.createObjectStore(KV_STORE);
            }
            // File cache store for large record lists
            if (!db.objectStoreNames.contains(CACHE_STORE)) {
              db.createObjectStore(CACHE_STORE);
            }
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
        return this.db;
      },
      async get(store, key) {
        const db = await this.open();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(store, 'readonly');
          const s = tx.objectStore(store);
          const req = s.get(key);
          req.onsuccess = () => resolve(req.result ?? null);
          req.onerror = () => reject(req.error);
        });
      },
      async set(store, key, val) {
        const db = await this.open();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(store, 'readwrite');
          const s = tx.objectStore(store);
          const req = s.put(val, key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      },
      async del(store, key) {
        const db = await this.open();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(store, 'readwrite');
          const s = tx.objectStore(store);
          const req = s.delete(key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      },
      async clearStore(store) {
        const db = await this.open();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(store, 'readwrite');
          const s = tx.objectStore(store);
          const req = s.clear();
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      },
    };

    // -----------------------------
    // File Cache (using IndexedDB)
    // -----------------------------
    const CHUNK_SIZE = 5000; // Records per chunk

    async function saveFileCache(records, folderName) {
      try {
        // Clear old cache first
        await idb.clearStore(CACHE_STORE);
        
        // Save folder name
        await idb.set(CACHE_STORE, 'folderName', folderName);
        
        // Save record count
        await idb.set(CACHE_STORE, 'recordCount', records.length);
        
        // Save records in chunks to avoid memory issues
        const cacheRecords = records.map(recordToCache);
        const chunkCount = Math.ceil(cacheRecords.length / CHUNK_SIZE);
        await idb.set(CACHE_STORE, 'chunkCount', chunkCount);
        
        for (let i = 0; i < chunkCount; i++) {
          const start = i * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, cacheRecords.length);
          const chunk = cacheRecords.slice(start, end);
          await idb.set(CACHE_STORE, `chunk_${i}`, chunk);
        }
        
        console.log(`File cache saved: ${records.length} records in ${chunkCount} chunks`);
        return true;
      } catch (e) {
        console.error('Failed to save file cache to IndexedDB:', e);
        setStatus(`å¿«å–å„²å­˜å¤±æ•—ï¼š${e?.message || e}`, 'error');
        return false;
      }
    }

    async function loadFileCache() {
      try {
        const folderName = await idb.get(CACHE_STORE, 'folderName');
        if (!folderName) return null;
        
        const chunkCount = await idb.get(CACHE_STORE, 'chunkCount');
        if (!chunkCount || chunkCount <= 0) return null;
        
        // Load all chunks
        const allRecords = [];
        for (let i = 0; i < chunkCount; i++) {
          const chunk = await idb.get(CACHE_STORE, `chunk_${i}`);
          if (chunk && Array.isArray(chunk)) {
            allRecords.push(...chunk);
          }
        }
        
        if (allRecords.length === 0) return null;
        
        const records = allRecords.map(parseRecordFromCache);
        console.log(`File cache loaded: ${records.length} records from ${chunkCount} chunks`);
        return { records, folderName };
      } catch (e) {
        console.error('Failed to load file cache from IndexedDB:', e);
        return null;
      }
    }

    // -----------------------------
    // Recent Tickers (localStorage - small data)
    // -----------------------------
    function loadRecentTickers() {
      try {
        const saved = localStorage.getItem(RECENT_TICKERS_KEY);
        if (saved) {
          state.recentTickers = JSON.parse(saved);
        }
      } catch (e) {
        state.recentTickers = [];
      }
    }

    function saveRecentTickers() {
      try {
        localStorage.setItem(RECENT_TICKERS_KEY, JSON.stringify(state.recentTickers));
      } catch (e) {
        // ignore
      }
    }

    function addRecentTicker(ticker) {
      if (!ticker) return;
      state.recentTickers = state.recentTickers.filter(t => t !== ticker);
      state.recentTickers.unshift(ticker);
      if (state.recentTickers.length > MAX_RECENT_TICKERS) {
        state.recentTickers = state.recentTickers.slice(0, MAX_RECENT_TICKERS);
      }
      saveRecentTickers();
      renderRecentTickers();
    }

    function renderRecentTickers() {
      if (state.recentTickers.length === 0) {
        el.recentTickers.innerHTML = '';
        return;
      }

      const availableTickers = new Set(state.displayRecords.map(r => r.ticker));
      const hasRecords = state.displayRecords.length > 0;
      const currentTicker = getSelectedTicker();

      el.recentTickers.innerHTML = `
        <div class="recentTickersLabel">å¸¸ç”¨ï¼š</div>
        ${state.recentTickers.map(t => {
          const isAvailable = !hasRecords || availableTickers.has(t);
          const isActive = t === currentTicker;
          const classes = ['btnTicker'];
          if (isActive) classes.push('active');
          if (hasRecords && !availableTickers.has(t)) classes.push('unavailable');
          return `<button class="${classes.join(' ')}" data-ticker="${escapeHtml(t)}" ${!isAvailable ? 'title="æ­¤ Ticker ä¸å­˜åœ¨æ–¼ç›®å‰è³‡æ–™å¤¾"' : ''}>${escapeHtml(t)}</button>`;
        }).join('')}
      `;

      el.recentTickers.querySelectorAll('.btnTicker').forEach(btn => {
        btn.addEventListener('click', () => {
          const ticker = btn.dataset.ticker;
          if (!ticker) return;
          
          if (state.displayRecords.length === 0) {
            setStatus('è«‹å…ˆé¸æ“‡è³‡æ–™å¤¾è¼‰å…¥æª”æ¡ˆã€‚', 'info');
            return;
          }
          
          const availableTickers = new Set(state.displayRecords.map(r => r.ticker));
          if (!availableTickers.has(ticker)) {
            setStatus(`Ticker "${ticker}" ä¸å­˜åœ¨æ–¼ç›®å‰è³‡æ–™å¤¾ã€‚`, 'error');
            return;
          }
          
          el.tickerSel.value = ticker;
          onTickerChange();
        });
      });
    }

    // -----------------------------
    // UI Updates
    // -----------------------------
    function updateCurrentInfo() {
      if (!state.tickerSelected || state.filtered.length === 0 || state.activeIndex < 0) {
        el.currentInfo.style.display = 'none';
        return;
      }

      const r = state.filtered[state.activeIndex];
      if (!r) {
        el.currentInfo.style.display = 'none';
        return;
      }

      el.currentInfo.style.display = 'grid';
      el.infoDate.textContent = `${r.date} ${r.time}`;
      el.infoFeature.textContent = r.feature;
      el.infoIndex.textContent = `${state.activeIndex + 1} / ${state.filtered.length}`;
    }

    function updateTopStatus() {
      if (!state.tickerSelected) {
        if (state.usingCache) {
          setStatus('ä½¿ç”¨å¿«å–æ¸…å–®ã€‚é¸æ“‡è³‡æ–™å¤¾å¾Œæ‰èƒ½ç€è¦½æª”æ¡ˆå…§å®¹ã€‚', 'info');
        } else if (state.displayRecords.length > 0) {
          setStatus('è«‹é¸æ“‡ Ticker é–‹å§‹ç€è¦½ã€‚', 'info');
        } else {
          setStatus('è«‹å…ˆæŒ‰ã€Œé¸æ“‡è³‡æ–™å¤¾ã€è¼‰å…¥ HTML å­˜æª”ã€‚', 'info');
        }
        el.openNewTabBtn.disabled = true;
        el.fullscreenBtn.disabled = true;
        updatePageTitle(null);
        return;
      }

      if (state.filtered.length === 0) {
        setStatus('å°šç„¡å¯é¡¯ç¤ºé …ç›®ã€‚', 'info');
        el.openNewTabBtn.disabled = true;
        el.fullscreenBtn.disabled = true;
        updatePageTitle(null);
        return;
      }

      const r = state.filtered[state.activeIndex] || null;
      if (!r) {
        setStatus(`å…± ${state.filtered.length} ç­†`, 'info');
        el.openNewTabBtn.disabled = true;
        el.fullscreenBtn.disabled = true;
        updatePageTitle(null);
        return;
      }

      if (state.usingCache) {
        setStatus(`${r.date} ${r.time} Â· ${r.feature} Â· ${state.activeIndex + 1}/${state.filtered.length} (éœ€é¸æ“‡è³‡æ–™å¤¾)`, 'info');
        el.openNewTabBtn.disabled = true;
        el.fullscreenBtn.disabled = true;
      } else {
        setStatus(`${r.date} ${r.time} Â· ${r.feature} Â· ${state.activeIndex + 1}/${state.filtered.length}`, 'ok');
        el.openNewTabBtn.disabled = false;
        el.fullscreenBtn.disabled = false;
      }
      updatePageTitle(r);
    }

    // -----------------------------
    // Actions
    // -----------------------------
    function rebuildTickerSelector() {
      const tickers = Array.from(new Set(state.displayRecords.map(r => r.ticker))).sort((a, b) => a.localeCompare(b));
      fillSelect(el.tickerSel, tickers, { placeholder: "-- è«‹é¸æ“‡ --" });
      el.tickerSel.value = "__PLACEHOLDER__";
      state.tickerSelected = false;
      renderRecentTickers();
    }

    function rebuildDateAndFeatureSelectors() {
      const dates = Array.from(new Set(state.filtered.map(r => r.date))).sort((a, b) => b.localeCompare(a));
      const features = Array.from(new Set(state.filtered.map(r => r.feature))).sort((a, b) => a.localeCompare(b));
      fillSelect(el.dateSel, dates, { placeholder: "-- é¸æ“‡ --" });
      fillSelect(el.featureSel, features, { placeholder: "-- é¸æ“‡ --" });
    }

    function onTickerChange() {
      const ticker = getSelectedTicker();
      state.tickerSelected = !!ticker;
      state.filtered = getFilteredByTicker();
      state.activeIndex = -1;

      // Rebuild feature index for fast navigation
      rebuildFeatureIndex();

      if (ticker) {
        addRecentTicker(ticker);
      }

      rebuildDateAndFeatureSelectors();

      if (state.tickerSelected && state.filtered.length > 0) {
        // Default to gamma feature if available
        if (featureIndex['gamma'] && featureIndex['gamma'].length > 0) {
          el.featureSel.value = 'gamma';
          state.activeIndex = featureIndex['gamma'][0];
        } else {
          state.activeIndex = 0;
        }
        openActive();
      } else {
        clearViewer();
      }

      updateCurrentInfo();
      updateTopStatus();
      renderRecentTickers();

      el.tickerSel.blur();
    }

    function jumpToDate() {
      const date = el.dateSel.value;
      if (date === "__PLACEHOLDER__" || !state.tickerSelected) return;

      const idx = state.filtered.findIndex(r => r.date === date);
      if (idx !== -1 && idx !== state.activeIndex) {
        setActiveIndexFast(idx);
      }

      el.dateSel.blur();
    }

    function jumpToFeature() {
      const feature = el.featureSel.value;
      if (feature === "__PLACEHOLDER__" || !state.tickerSelected) return;

      const currRecord = state.filtered[state.activeIndex];
      let idx = -1;

      if (currRecord) {
        idx = state.filtered.findIndex(r => r.date === currRecord.date && r.time === currRecord.time && r.feature === feature);
        if (idx === -1) {
          idx = state.filtered.findIndex(r => r.date === currRecord.date && r.feature === feature);
        }
      }

      if (idx === -1) {
        idx = state.filtered.findIndex(r => r.feature === feature);
      }

      if (idx !== -1 && idx !== state.activeIndex) {
        setActiveIndexFast(idx);
      }

      el.featureSel.blur();
    }

    function clearViewer() {
      if (state.activeObjectUrl) {
        URL.revokeObjectURL(state.activeObjectUrl);
        state.activeObjectUrl = null;
      }
      el.viewerFrame.removeAttribute('src');
      el.viewerFrame.removeAttribute('srcdoc');
      el.viewerFrame.style.background = '#ffffff';
      el.openNewTabBtn.disabled = true;
      el.fullscreenBtn.disabled = true;
      showLoading(false);
    }

    function openRecord(record) {
      if (state.usingCache || !record.file) {
        const file = state.fileMap.get(record.relPath);
        if (!file) {
          clearViewer();
          setStatus(`è«‹å…ˆé¸æ“‡è³‡æ–™å¤¾ä»¥ç€è¦½ ${record.name}`, 'info');
          return;
        }
        record.file = file;
      }

      if (state.activeObjectUrl) {
        URL.revokeObjectURL(state.activeObjectUrl);
        state.activeObjectUrl = null;
      }

      try {
        const url = URL.createObjectURL(record.file);
        state.activeObjectUrl = url;

        el.viewerFrame.src = url;

        if (state.newTabBlobUrl) {
          URL.revokeObjectURL(state.newTabBlobUrl);
        }
        state.newTabBlobUrl = URL.createObjectURL(record.file);

        el.openNewTabBtn.disabled = false;
        el.fullscreenBtn.disabled = false;
      } catch (e) {
        record.file.text().then(html => {
          el.viewerFrame.srcdoc = html;
          state.newTabBlobUrl = null;
          el.openNewTabBtn.disabled = true;
          el.fullscreenBtn.disabled = false;
        }).catch(err => {
          clearViewer();
          setStatus(`è®€å–æª”æ¡ˆå¤±æ•—ï¼š${err?.message || err}`, 'error');
        });
      }
    }

    function openActive() {
      if (state.activeIndex < 0 || state.activeIndex >= state.filtered.length) return;
      const r = state.filtered[state.activeIndex];
      openRecord(r);
      updateCurrentInfo();
      updateTopStatus();
    }

    function setActiveIndexFast(idx) {
      if (state.filtered.length === 0) return;
      state.activeIndex = ((idx % state.filtered.length) + state.filtered.length) % state.filtered.length;
      openActive();
    }

    async function initializeFromCache() {
      try {
        const cache = await loadFileCache();
        if (!cache) return false;

        state.cachedRecords = cache.records;
        state.displayRecords = cache.records;
        state.folderDisplayName = cache.folderName;
        state.usingCache = true;
        state.hasFolderSelected = false;

        updateFolderDisplay();
        rebuildTickerSelector();

        setStatus(`å·²è¼‰å…¥ ${cache.records.length} ç­†å¿«å–ã€‚`, 'ok');
        return true;
      } catch (e) {
        console.error('Failed to initialize from cache:', e);
        return false;
      }
    }

    function clearAll() {
      state.files = [];
      state.cachedRecords = [];
      state.displayRecords = [];
      state.filtered = [];
      state.activeIndex = -1;
      state.folderDisplayName = "";
      state.tickerSelected = false;
      state.lastDirHandle = null;
      state.hasFolderSelected = false;
      state.usingCache = false;
      state.fileMap.clear();
      updateFolderDisplay();
      fillSelect(el.tickerSel, [], { placeholder: "-- è«‹é¸æ“‡ --" });
      fillSelect(el.dateSel, [], { placeholder: "-- é¸æ“‡ --" });
      fillSelect(el.featureSel, [], { placeholder: "-- é¸æ“‡ --" });
      el.currentInfo.style.display = 'none';
      renderRecentTickers();
      clearViewer();
      setStatus('è«‹å…ˆæŒ‰ã€Œé¸æ“‡è³‡æ–™å¤¾ã€è¼‰å…¥ HTML å­˜æª”ã€‚', 'info');
      updatePageTitle(null);
    }

    // -----------------------------
    // Directory Handle Persistence
    // -----------------------------
    async function canUseDirectoryHandle() {
      return typeof window.showDirectoryPicker === 'function' && typeof FileSystemDirectoryHandle !== 'undefined';
    }

    async function tryAutoReconnectOnLoad(hasCachedData = false) {
      try {
        if (!(await canUseDirectoryHandle())) return;
        const saved = await idb.get(KV_STORE, 'lastDirHandle');
        if (!saved) return;

        const perm = await saved.queryPermission?.({ mode: 'read' });
        state.lastDirHandle = saved;

        if (perm === 'granted') {
          setStatus('è‡ªå‹•é€£çµæª”æ¡ˆä¸­...', 'info');
          // If we have cache, just link files; otherwise full scan
          if (hasCachedData) {
            await linkFilesToCachedRecords(saved);
          } else {
            await scanDirectoryHandle(saved);
          }
        }
        // If not granted, user will need to click "æˆæ¬Šå­˜å–" button
      } catch {
        // ignore
      }
    }

    async function scanDirectoryHandle(dirHandle) {
      state.folderDisplayName = dirHandle?.name || '(è³‡æ–™å¤¾)';
      state.hasFolderSelected = true;
      state.usingCache = false;
      updateFolderDisplay();
      state.lastDirHandle = dirHandle;

      const records = [];
      let scannedCount = 0;

      el.scanProgress.style.display = 'block';
      el.scanProgressText.textContent = 'æƒæä¸­...';
      el.scanProgressFill.style.width = '0%';

      state.fileMap.clear();

      async function walk(handle, prefix) {
        for await (const entry of handle.values()) {
          if (entry.kind === 'directory') {
            await walk(entry, `${prefix}${entry.name}/`);
          } else if (entry.kind === 'file') {
            scannedCount++;
            if (scannedCount % 50 === 0) {
              el.scanProgressText.textContent = `å·²æƒæ ${scannedCount} å€‹æª”æ¡ˆ...`;
              await new Promise(r => setTimeout(r, 0));
            }
            if (!entry.name.toLowerCase().endsWith('.html')) continue;
            const file = await entry.getFile();
            const relPath = `${prefix}${entry.name}`;
            const rec = parseRecordFromFileLike({ file, relPath, name: entry.name });
            if (!rec) continue;
            records.push(rec);
            state.fileMap.set(relPath, file);
          }
        }
      }

      await walk(dirHandle, `${state.folderDisplayName}/`);

      el.scanProgress.style.display = 'none';

      if (records.length === 0) {
        setStatus('æ‰¾ä¸åˆ°ç¬¦åˆå‘½åè¦å‰‡çš„ .htmlã€‚æ ¼å¼ï¼šyyyy-mm-dd_æ™‚é–“_ticker_åŠŸèƒ½.html', 'error');
        return;
      }

      state.files = records.sort((a, b) => b.ts - a.ts || a.relPath.localeCompare(b.relPath));
      state.displayRecords = state.files;

      // Save to IndexedDB cache
      await saveFileCache(state.files, state.folderDisplayName);

      rebuildTickerSelector();
      rebuildDateAndFeatureSelectors();

      state.filtered = [];
      state.activeIndex = -1;
      state.tickerSelected = false;

      updateCurrentInfo();
      updateTopStatus();

      setStatus(`å·²è¼‰å…¥ ${state.files.length} å€‹ HTMLã€‚è«‹é¸æ“‡ Tickerã€‚`, 'ok');
    }

    async function scanFiles(fileList) {
      const files = Array.from(fileList || []);
      if (files.length === 0) {
        setStatus('ä½ æ²’æœ‰é¸åˆ°ä»»ä½•æª”æ¡ˆã€‚', 'error');
        return;
      }

      el.scanProgress.style.display = 'block';
      el.scanProgressText.textContent = 'æƒæä¸­...';
      el.scanProgressFill.style.width = '0%';

      const rp = files[0].webkitRelativePath || "";
      state.folderDisplayName = rp ? rp.split('/')[0] : "(å·²é¸å–)";
      state.hasFolderSelected = true;
      state.usingCache = false;
      updateFolderDisplay();
      state.lastDirHandle = null;

      state.fileMap.clear();

      const records = [];
      const total = files.length;

      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        if (i % 50 === 0) {
          el.scanProgressText.textContent = `å·²æƒæ ${i}/${total} å€‹æª”æ¡ˆ...`;
          el.scanProgressFill.style.width = `${Math.round(i / total * 100)}%`;
          await new Promise(r => setTimeout(r, 0));
        }
        if (!f.name.toLowerCase().endsWith('.html')) continue;
        const relPath = f.webkitRelativePath || f.name;
        const rec = parseRecordFromFileLike({ file: f, relPath, name: f.name });
        if (!rec) continue;
        records.push(rec);
        state.fileMap.set(relPath, f);
      }

      el.scanProgress.style.display = 'none';

      if (records.length === 0) {
        setStatus('æ‰¾ä¸åˆ°ç¬¦åˆå‘½åè¦å‰‡çš„ .htmlã€‚æ ¼å¼ï¼šyyyy-mm-dd_æ™‚é–“_ticker_åŠŸèƒ½.html', 'error');
        return;
      }

      state.files = records.sort((a, b) => b.ts - a.ts || a.relPath.localeCompare(b.relPath));
      state.displayRecords = state.files;

      // Save to IndexedDB cache
      await saveFileCache(state.files, state.folderDisplayName);

      rebuildTickerSelector();
      rebuildDateAndFeatureSelectors();

      state.filtered = [];
      state.activeIndex = -1;
      state.tickerSelected = false;

      updateCurrentInfo();
      updateTopStatus();

      setStatus(`å·²è¼‰å…¥ ${state.files.length} å€‹ HTMLã€‚è«‹é¸æ“‡ Tickerã€‚`, 'ok');
    }

    // -----------------------------
    // Link files to cached records (fast, no re-parsing)
    // -----------------------------
    async function linkFilesToCachedRecords(dirHandle) {
      state.folderDisplayName = dirHandle?.name || '(è³‡æ–™å¤¾)';
      state.hasFolderSelected = true;
      state.usingCache = false;
      updateFolderDisplay();
      state.lastDirHandle = dirHandle;

      el.scanProgress.style.display = 'block';
      el.scanProgressText.textContent = 'é€£çµæª”æ¡ˆä¸­...';
      el.scanProgressFill.style.width = '0%';

      state.fileMap.clear();
      let linkedCount = 0;
      let scannedCount = 0;

      // Build a set of relPaths we need
      const neededPaths = new Set(state.displayRecords.map(r => r.relPath));

      async function walk(handle, prefix) {
        for await (const entry of handle.values()) {
          if (entry.kind === 'directory') {
            await walk(entry, `${prefix}${entry.name}/`);
          } else if (entry.kind === 'file') {
            scannedCount++;
            if (scannedCount % 100 === 0) {
              el.scanProgressText.textContent = `é€£çµä¸­... ${linkedCount}/${state.displayRecords.length}`;
              await new Promise(r => setTimeout(r, 0));
            }
            if (!entry.name.toLowerCase().endsWith('.html')) continue;
            const relPath = `${prefix}${entry.name}`;
            if (neededPaths.has(relPath)) {
              const file = await entry.getFile();
              state.fileMap.set(relPath, file);
              linkedCount++;
            }
          }
        }
      }

      await walk(dirHandle, `${state.folderDisplayName}/`);

      el.scanProgress.style.display = 'none';

      // Update records to have file references
      for (const r of state.displayRecords) {
        const file = state.fileMap.get(r.relPath);
        if (file) r.file = file;
      }

      if (linkedCount > 0) {
        setStatus(`å·²é€£çµ ${linkedCount} å€‹æª”æ¡ˆï¼Œå¯é–‹å§‹ç€è¦½ã€‚`, 'ok');
      } else {
        setStatus(`é€£çµå¤±æ•—ï¼Œè«‹ç¢ºèªé¸æ“‡æ­£ç¢ºçš„è³‡æ–™å¤¾ã€‚`, 'error');
      }
      updateTopStatus();
    }

    async function linkFilesFromFileList(fileList) {
      const files = Array.from(fileList || []);
      if (files.length === 0) {
        setStatus('ä½ æ²’æœ‰é¸åˆ°ä»»ä½•æª”æ¡ˆã€‚', 'error');
        return;
      }

      el.scanProgress.style.display = 'block';
      el.scanProgressText.textContent = 'é€£çµæª”æ¡ˆä¸­...';
      el.scanProgressFill.style.width = '0%';

      const rp = files[0].webkitRelativePath || "";
      state.folderDisplayName = rp ? rp.split('/')[0] : "(å·²é¸å–)";
      state.hasFolderSelected = true;
      state.usingCache = false;
      updateFolderDisplay();
      state.lastDirHandle = null;

      state.fileMap.clear();
      const neededPaths = new Set(state.displayRecords.map(r => r.relPath));
      let linkedCount = 0;

      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        if (i % 100 === 0) {
          el.scanProgressText.textContent = `é€£çµä¸­... ${linkedCount}/${state.displayRecords.length}`;
          el.scanProgressFill.style.width = `${Math.round(i / files.length * 100)}%`;
          await new Promise(r => setTimeout(r, 0));
        }
        if (!f.name.toLowerCase().endsWith('.html')) continue;
        const relPath = f.webkitRelativePath || f.name;
        if (neededPaths.has(relPath)) {
          state.fileMap.set(relPath, f);
          linkedCount++;
        }
      }

      el.scanProgress.style.display = 'none';

      for (const r of state.displayRecords) {
        const file = state.fileMap.get(r.relPath);
        if (file) r.file = file;
      }

      if (linkedCount > 0) {
        setStatus(`å·²é€£çµ ${linkedCount} å€‹æª”æ¡ˆï¼Œå¯é–‹å§‹ç€è¦½ã€‚`, 'ok');
      } else {
        setStatus(`é€£çµå¤±æ•—ï¼Œè«‹ç¢ºèªé¸æ“‡æ­£ç¢ºçš„è³‡æ–™å¤¾ã€‚`, 'error');
      }
      updateTopStatus();
    }

    // -----------------------------
    // Events
    // -----------------------------
    
    // Authorize button: just get file access for cached records
    el.authorizeBtn.addEventListener('click', async () => {
      try {
        if (await canUseDirectoryHandle()) {
          const handle = await window.showDirectoryPicker({ mode: 'read' });
          try {
            await idb.set(KV_STORE, 'lastDirHandle', handle);
          } catch {
            // ignore
          }
          await linkFilesToCachedRecords(handle);
          return;
        }
      } catch (e) {
        if (e.name !== 'AbortError') {
          setStatus('æ­¤ç’°å¢ƒç„¡æ³•ä½¿ç”¨ç›®éŒ„é¸å–ï¼›æ”¹ç”¨æœ¬æ©Ÿé¸å–ã€‚', 'info');
        } else {
          return;
        }
      }
      // Fallback for file:// or unsupported browsers
      el.dirInput.dataset.mode = 'authorize';
      el.dirInput.click();
    });

    // Pick/Change folder button: always do full scan (new folder)
    el.pickFolderBtn.addEventListener('click', async () => {
      try {
        if (await canUseDirectoryHandle()) {
          const handle = await window.showDirectoryPicker({ mode: 'read' });
          try {
            await idb.set(KV_STORE, 'lastDirHandle', handle);
          } catch {
            // ignore
          }
          await scanDirectoryHandle(handle);
          return;
        }
      } catch (e) {
        if (e.name !== 'AbortError') {
          setStatus('æ­¤ç’°å¢ƒç„¡æ³•ä½¿ç”¨ã€Œè¨˜ä½è³‡æ–™å¤¾ã€ï¼›æ”¹ç”¨æœ¬æ©Ÿé¸å–ã€‚', 'info');
        } else {
          return;
        }
      }
      el.dirInput.dataset.mode = 'scan';
      el.dirInput.click();
    });

    el.dirInput.addEventListener('change', async (e) => {
      const mode = el.dirInput.dataset.mode || 'scan';
      const hasCache = state.displayRecords.length > 0 && state.usingCache;
      
      if (mode === 'authorize' && hasCache) {
        await linkFilesFromFileList(e.target.files);
      } else {
        await scanFiles(e.target.files);
      }
      
      // Reset mode
      el.dirInput.dataset.mode = 'scan';
    });

    el.rescanBtn.addEventListener('click', async () => {
      if (state.lastDirHandle) {
        try {
          const perm = await state.lastDirHandle.requestPermission?.({ mode: 'read' });
          if (perm === 'granted') {
            await scanDirectoryHandle(state.lastDirHandle);
            return;
          }
        } catch (e) {
          // Fall through to folder selection
        }
      }
      
      el.pickFolderBtn.click();
    });

    el.tickerSel.addEventListener('change', onTickerChange);
    el.dateSel.addEventListener('change', jumpToDate);
    el.featureSel.addEventListener('change', jumpToFeature);

    function setSidebarCollapsed(collapsed) {
      if (collapsed) document.body.classList.add('sidebarCollapsed');
      else document.body.classList.remove('sidebarCollapsed');
      el.toggleSidebarBtn.textContent = collapsed ? 'å±•é–‹å´æ¬„' : 'æ”¶åˆå´æ¬„';
    }

    el.collapseBtn.addEventListener('click', () => setSidebarCollapsed(true));
    el.toggleSidebarBtn.addEventListener('click', () => {
      const collapsed = document.body.classList.contains('sidebarCollapsed');
      setSidebarCollapsed(!collapsed);
    });

    el.fullscreenBtn.addEventListener('click', async () => {
      const target = document.getElementById('mainPanel');
      try {
        if (!document.fullscreenElement) await target.requestFullscreen();
        else await document.exitFullscreen();
      } catch (e) {
        setStatus(`å…¨è¢å¹•å¤±æ•—ï¼š${e?.message || e}`, 'error');
      }
    });

    el.openNewTabBtn.addEventListener('click', () => {
      if (!state.newTabBlobUrl) return;
      window.open(state.newTabBlobUrl, '_blank', 'noopener,noreferrer');
    });

    // Pre-built indexes for fast navigation
    let featureIndex = {}; // feature -> sorted array of indices in state.filtered
    let allFeaturesSorted = [];

    function rebuildFeatureIndex() {
      featureIndex = {};
      for (let i = 0; i < state.filtered.length; i++) {
        const r = state.filtered[i];
        if (!featureIndex[r.feature]) {
          featureIndex[r.feature] = [];
        }
        featureIndex[r.feature].push(i);
      }
      allFeaturesSorted = Object.keys(featureIndex).sort((a, b) => a.localeCompare(b));
    }

    document.addEventListener('keydown', (e) => {
      if (isTypingContext()) return;
      if (!state.tickerSelected || state.filtered.length === 0 || state.activeIndex < 0) return;

      const currRecord = state.filtered[state.activeIndex];
      if (!currRecord) return;

      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        e.preventDefault();
        // Navigate within same feature by date/time
        const indices = featureIndex[currRecord.feature];
        if (!indices || indices.length <= 1) return;
        
        const currPosInFeature = indices.indexOf(state.activeIndex);
        if (currPosInFeature === -1) return;
        
        const dir = e.key === 'ArrowUp' ? -1 : 1;
        const nextPosInFeature = (currPosInFeature + dir + indices.length) % indices.length;
        const nextIdx = indices[nextPosInFeature];
        
        state.activeIndex = nextIdx;
        openActive();
        return;
      }

      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
        // Switch feature, find closest date/time
        if (allFeaturesSorted.length <= 1) return;

        const currFeatureIdx = allFeaturesSorted.indexOf(currRecord.feature);
        if (currFeatureIdx === -1) return;
        
        const dir = e.key === 'ArrowLeft' ? -1 : 1;
        const nextFeatureIdx = (currFeatureIdx + dir + allFeaturesSorted.length) % allFeaturesSorted.length;
        const nextFeature = allFeaturesSorted[nextFeatureIdx];

        // Find closest date/time in the new feature
        const targetIndices = featureIndex[nextFeature];
        if (!targetIndices || targetIndices.length === 0) return;

        // Binary search for closest timestamp
        const currTs = currRecord.ts;
        let closestIdx = targetIndices[0];
        let closestDiff = Math.abs(state.filtered[closestIdx].ts - currTs);
        
        for (const idx of targetIndices) {
          const diff = Math.abs(state.filtered[idx].ts - currTs);
          if (diff < closestDiff) {
            closestDiff = diff;
            closestIdx = idx;
          }
        }

        state.activeIndex = closestIdx;
        el.featureSel.value = nextFeature;
        openActive();
      }
    });

    // -----------------------------
    // Init (async)
    // -----------------------------
    (async function init() {
      loadRecentTickers();
      
      // Try to load from IndexedDB cache first (instant for UI)
      const hasCachedData = await initializeFromCache();
      
      if (!hasCachedData) {
        clearAll();
      }
      
      renderRecentTickers();
      
      // Try to auto-reconnect with saved directory handle
      await tryAutoReconnectOnLoad(hasCachedData);
    })();
  </script>
</body>
</html>
