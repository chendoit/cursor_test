<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GEX HTML Archive Viewer</title>

  <!-- Requirement: use Plotly CDN -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

  <style>
    :root {
      --bg0: #0b0f14;
      --bg1: #111826;
      --bg2: #182235;
      --text0: #e6edf3;
      --text1: #94a3b8;
      --border: rgba(148, 163, 184, 0.18);
      --accent: #4cc9f0;
      --accent2: #b5179e;
      --danger: #f87171;
      --ok: #34d399;
      --warn: #fbbf24;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --topbar-h: 48px;
      --sidebar-w: 340px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 20%, rgba(76, 201, 240, 0.10), transparent 55%),
                  radial-gradient(1200px 800px at 80% 80%, rgba(181, 23, 158, 0.08), transparent 55%),
                  var(--bg0);
      color: var(--text0);
      font-family: var(--sans);
      overflow: hidden;
    }

    .app {
      height: 100%;
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      gap: 10px;
      padding: 10px;
      min-height: 0;
    }

    .sidebar {
      background: linear-gradient(180deg, rgba(17, 24, 38, 0.98), rgba(17, 24, 38, 0.92));
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-width: 260px;
      min-height: 0;
    }

    .sidebarHeader {
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .titleBlock {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .title {
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.2px;
      line-height: 1.1;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    .subtitle {
      font-size: 12px;
      color: var(--text1);
      font-family: var(--mono);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 210px;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.8);
      color: var(--text0);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease;
      user-select: none;
    }
    .btn:hover { border-color: rgba(76, 201, 240, 0.45); transform: translateY(-1px); }
    .btnPrimary {
      border-color: rgba(76, 201, 240, 0.40);
      background: linear-gradient(135deg, rgba(76, 201, 240, 0.22), rgba(181, 23, 158, 0.14));
    }
    .btnDanger { border-color: rgba(248, 113, 113, 0.35); }

    .controls {
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    label {
      display: block;
      font-size: 11px;
      color: var(--text1);
      margin: 0 0 6px;
    }

    select, input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.65);
      color: var(--text0);
      font-size: 12px;
      font-family: var(--mono);
      outline: none;
    }
    select:focus, input[type="text"]:focus {
      border-color: rgba(76, 201, 240, 0.55);
      box-shadow: 0 0 0 3px rgba(76, 201, 240, 0.12);
    }

    .list {
      flex: 1;
      padding: 10px 12px 12px;
      overflow: auto;
      border-top: 1px solid var(--border);
      min-height: 0;
    }

    .listHeader {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }
    .listTitle {
      font-size: 12px;
      color: var(--text1);
      font-family: var(--mono);
    }
    .pill {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.5);
      color: var(--text1);
      font-family: var(--mono);
      white-space: nowrap;
    }

    .item {
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: rgba(24, 34, 53, 0.45);
      border-radius: 12px;
      padding: 10px 10px;
      display: grid;
      gap: 6px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease;
    }
    .item:hover { border-color: rgba(76, 201, 240, 0.35); background: rgba(24, 34, 53, 0.55); }
    .item.active { border-color: rgba(76, 201, 240, 0.60); box-shadow: 0 0 0 3px rgba(76, 201, 240, 0.12); }

    .itemTop {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .itemMeta {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text0);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }
    .tag {
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(76, 201, 240, 0.95);
      border: 1px solid rgba(76, 201, 240, 0.35);
      background: rgba(76, 201, 240, 0.08);
      padding: 2px 7px;
      border-radius: 999px;
      white-space: nowrap;
    }
    .path {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text1);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .main {
      background: linear-gradient(180deg, rgba(17, 24, 38, 0.92), rgba(17, 24, 38, 0.78));
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      grid-template-rows: var(--topbar-h) 1fr;
      min-width: 320px;
      min-height: 0;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.35);
    }

    .status {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text1);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .viewer {
      min-height: 0;
      background: rgba(11, 15, 20, 0.35);
    }

    iframe {
      width: 100%;
      height: 100%;
      border: 0;
      background: #ffffff;
    }

    .hint {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text1);
      padding: 14px;
      line-height: 1.5;
    }
    .hint kbd {
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: rgba(24, 34, 53, 0.55);
      color: var(--text0);
    }

    /* collapsed sidebar */
    body.sidebarCollapsed .app { grid-template-columns: 1fr; }
    body.sidebarCollapsed .sidebar { display: none; }
    body.sidebarCollapsed .main { min-width: 0; }

    @media (max-width: 980px) {
      .app { grid-template-columns: 1fr; }
      .sidebar { order: 2; min-width: 0; }
      .main { order: 1; }
      .viewer { height: calc(100vh - 10px - 10px - var(--topbar-h) - 0px); }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <div class="sidebarHeader">
        <div class="titleBlock">
          <div class="title">GEX HTML Archive Viewer</div>
          <div class="subtitle" id="folderLabel">尚未選擇資料夾</div>
        </div>
        <button class="btn" id="collapseBtn" title="收合側欄">收合</button>
      </div>

      <div class="controls">
        <input id="dirInput" type="file" webkitdirectory multiple style="display:none" />

        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <button class="btn btnPrimary" id="pickFolderBtn">選擇資料夾</button>
          <button class="btn" id="reconnectBtn" title="若已記住資料夾，嘗試自動連線" disabled>重新連線</button>
          <button class="btn" id="forgetBtn" title="清除已記住的資料夾" disabled>忘記</button>
          <button class="btn btnDanger" id="clearBtn" title="清空目前清單">清空</button>
        </div>
        <div style="font-size:11px; color:var(--ok); margin-top:4px;">
          ⚠️ 瀏覽器可能顯示「上傳」字樣，但<strong>實際不會上傳或複製</strong>，只在本機讀取。
        </div>

        <div class="row">
          <div>
            <label for="dateSel">日期</label>
            <select id="dateSel"></select>
          </div>
          <div>
            <label for="tickerSel">Ticker</label>
            <select id="tickerSel"></select>
          </div>
        </div>

        <div class="row">
          <div>
            <label for="featureSel">功能</label>
            <select id="featureSel"></select>
          </div>
          <div>
            <label for="searchTxt">搜尋</label>
            <input id="searchTxt" type="text" placeholder="檔名/路徑關鍵字" />
          </div>
        </div>

        <div class="hint" style="padding: 10px 2px 0;">
          鍵盤：<kbd>↑</kbd>/<kbd>↓</kbd> 同 ticker 上/下一個；
          <kbd>←</kbd>/<kbd>→</kbd> 切換功能。
        </div>
      </div>

      <div class="list">
        <div class="listHeader">
          <div class="listTitle">檔案列表（篩選後）</div>
          <div class="pill" id="countPill">0</div>
        </div>
        <div id="listItems"></div>
      </div>
    </aside>

    <main class="main" id="mainPanel">
      <div class="topbar">
        <div class="status" id="statusText">請先按「選擇資料夾」載入 HTML 存檔。</div>
        <div class="actions">
          <button class="btn" id="toggleSidebarBtn" title="收合/展開側欄">收合側欄</button>
          <button class="btn" id="openNewTabBtn" title="用新分頁開啟目前檔案（Blob URL）" disabled>新分頁開啟</button>
          <button class="btn" id="fullscreenBtn" title="全螢幕" disabled>全螢幕</button>
        </div>
      </div>
      <div class="viewer">
        <iframe id="viewerFrame" title="HTML Viewer"></iframe>
      </div>
    </main>
  </div>

  <script>
    // -----------------------------
    // State
    // -----------------------------
    const state = {
      files: [], // parsed records
      filtered: [],
      activeIndex: -1,
      activeObjectUrl: null,
      activeBlobUrlForNewTab: null,
      folderDisplayName: "",
    };

    // -----------------------------
    // DOM
    // -----------------------------
    const el = {
      dirInput: document.getElementById('dirInput'),
      pickFolderBtn: document.getElementById('pickFolderBtn'),
      reconnectBtn: document.getElementById('reconnectBtn'),
      forgetBtn: document.getElementById('forgetBtn'),
      clearBtn: document.getElementById('clearBtn'),
      folderLabel: document.getElementById('folderLabel'),
      dateSel: document.getElementById('dateSel'),
      tickerSel: document.getElementById('tickerSel'),
      featureSel: document.getElementById('featureSel'),
      searchTxt: document.getElementById('searchTxt'),
      listItems: document.getElementById('listItems'),
      countPill: document.getElementById('countPill'),
      viewerFrame: document.getElementById('viewerFrame'),
      statusText: document.getElementById('statusText'),
      collapseBtn: document.getElementById('collapseBtn'),
      toggleSidebarBtn: document.getElementById('toggleSidebarBtn'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      openNewTabBtn: document.getElementById('openNewTabBtn'),
    };

    // -----------------------------
    // Helpers
    // -----------------------------
    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function normalizeTime(raw) {
      const t = raw.replace(';', ':');
      // Expect HH:MM
      return t;
    }

    function parseRecordFromFileLike({ file, relPath, name }) {
      const m = name.match(/^(\d{4}-\d{2}-\d{2})_(\d{2}[;:]\d{2})_([A-Za-z0-9]+)_(.+)\.html$/i);
      if (!m) return null;

      const date = m[1];
      const time = normalizeTime(m[2]);
      const ticker = m[3].toUpperCase();
      const feature = m[4];
      const dt = new Date(`${date}T${time}:00`);
      const ts = Number.isFinite(dt.getTime()) ? dt.getTime() : null;
      if (ts === null) return null;

      return {
        file,
        relPath,
        name,
        date,
        time,
        ticker,
        feature,
        ts,
      };
    }

    function setStatus(text, kind = "info") {
      const prefix = kind === "error" ? "✗ " : kind === "ok" ? "✓ " : "• ";
      el.statusText.textContent = `${prefix}${text}`;
    }

    function fillSelect(selectEl, values, { includeAll = true, allLabel = "All" } = {}) {
      const curr = selectEl.value;
      const opts = [];
      if (includeAll) opts.push({ value: "__ALL__", label: allLabel });
      for (const v of values) opts.push({ value: v, label: v });
      selectEl.innerHTML = opts.map(o => `<option value="${escapeHtml(o.value)}">${escapeHtml(o.label)}</option>`).join('');
      // Try keep selection
      if (opts.some(o => o.value === curr)) selectEl.value = curr;
      else selectEl.value = includeAll ? "__ALL__" : (values[0] ?? "");
    }

    function activeFilters() {
      return {
        date: el.dateSel.value,
        ticker: el.tickerSel.value,
        feature: el.featureSel.value,
        q: (el.searchTxt.value || "").trim().toLowerCase(),
      };
    }

    function getFiltered(records) {
      const f = activeFilters();
      return records.filter(r => {
        if (f.date !== "__ALL__" && r.date !== f.date) return false;
        if (f.ticker !== "__ALL__" && r.ticker !== f.ticker) return false;
        if (f.feature !== "__ALL__" && r.feature !== f.feature) return false;
        if (f.q) {
          const hay = `${r.name} ${r.relPath}`.toLowerCase();
          if (!hay.includes(f.q)) return false;
        }
        return true;
      }).sort((a, b) => a.ts - b.ts || a.relPath.localeCompare(b.relPath));
    }

    function availableFeatureCycleSet() {
      // Cycle features only when ticker chosen (not All), and within current date filter.
      const f = activeFilters();
      if (f.ticker === "__ALL__") return [];
      const set = new Set();
      for (const r of state.files) {
        if (r.ticker !== f.ticker) continue;
        if (f.date !== "__ALL__" && r.date !== f.date) continue;
        // search q also affects "what I see"; but for cycle, keep it simple: ignore search.
        set.add(r.feature);
      }
      return Array.from(set).sort((a, b) => a.localeCompare(b));
    }

    function isTypingContext() {
      const a = document.activeElement;
      if (!a) return false;
      const tag = a.tagName;
      return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || a.isContentEditable;
    }

    // -----------------------------
    // Rendering
    // -----------------------------
    function renderList() {
      const list = state.filtered;
      el.countPill.textContent = String(list.length);

      if (list.length === 0) {
        el.listItems.innerHTML = `<div class="hint">沒有符合條件的檔案。<br/>提示：先按「選擇資料夾」，或把篩選改成 All。</div>`;
        return;
      }

      el.listItems.innerHTML = list.map((r, idx) => {
        const active = idx === state.activeIndex ? "active" : "";
        return `
          <div class="item ${active}" data-idx="${idx}">
            <div class="itemTop">
              <div class="itemMeta">${escapeHtml(r.date)} ${escapeHtml(r.time)} · ${escapeHtml(r.ticker)}</div>
              <div class="tag">${escapeHtml(r.feature)}</div>
            </div>
            <div class="path">${escapeHtml(r.relPath)}</div>
          </div>
        `;
      }).join('');
    }

    // Plotly timeline removed by request.

    function updateTopStatus() {
      const f = activeFilters();
      if (state.filtered.length === 0) {
        setStatus('尚無可顯示項目。', 'info');
        el.openNewTabBtn.disabled = true;
        el.fullscreenBtn.disabled = true;
        return;
      }
      const r = state.filtered[state.activeIndex] || null;
      const idxInfo = `${Math.max(0, state.activeIndex) + 1}/${state.filtered.length}`;
      const filterInfo = `日期=${f.date === "__ALL__" ? "All" : f.date} · Ticker=${f.ticker === "__ALL__" ? "All" : f.ticker} · 功能=${f.feature === "__ALL__" ? "All" : f.feature}`;

      if (!r) {
        setStatus(`${filterInfo} · ${idxInfo}`, 'info');
        el.openNewTabBtn.disabled = true;
        el.fullscreenBtn.disabled = true;
        return;
      }

      setStatus(`${r.date} ${r.time} ${r.ticker} · ${r.feature} · ${idxInfo}`, 'ok');
      el.openNewTabBtn.disabled = !state.activeBlobUrlForNewTab;
      el.fullscreenBtn.disabled = false;
    }

    // -----------------------------
    // Actions
    // -----------------------------
    function rebuildFiltersAndView({ keepNearestToTs = null } = {}) {
      state.filtered = getFiltered(state.files);

      // rebuild dropdown options based on all scanned files (not filtered)
      const allDates = Array.from(new Set(state.files.map(r => r.date))).sort((a, b) => a.localeCompare(b));
      const allTickers = Array.from(new Set(state.files.map(r => r.ticker))).sort((a, b) => a.localeCompare(b));
      const allFeatures = Array.from(new Set(state.files.map(r => r.feature))).sort((a, b) => a.localeCompare(b));
      fillSelect(el.dateSel, allDates, { includeAll: true, allLabel: "All" });
      fillSelect(el.tickerSel, allTickers, { includeAll: true, allLabel: "All" });
      fillSelect(el.featureSel, allFeatures, { includeAll: true, allLabel: "All" });

      // active index
      if (state.filtered.length === 0) {
        state.activeIndex = -1;
        clearViewer();
      } else if (keepNearestToTs != null) {
        let best = 0;
        let bestScore = Infinity;
        for (let i = 0; i < state.filtered.length; i++) {
          const score = Math.abs(state.filtered[i].ts - keepNearestToTs);
          if (score < bestScore) { bestScore = score; best = i; }
        }
        state.activeIndex = best;
        openActive();
      } else {
        state.activeIndex = Math.min(Math.max(state.activeIndex, 0), state.filtered.length - 1);
        if (state.activeIndex === -1) state.activeIndex = 0;
        openActive();
      }

      renderList();
      updateTopStatus();
    }

    function clearViewer() {
      if (state.activeObjectUrl) {
        URL.revokeObjectURL(state.activeObjectUrl);
        state.activeObjectUrl = null;
      }
      state.activeBlobUrlForNewTab = null;
      el.viewerFrame.removeAttribute('src');
      el.viewerFrame.removeAttribute('srcdoc');
      el.viewerFrame.style.background = '#ffffff';
      el.openNewTabBtn.disabled = true;
      el.fullscreenBtn.disabled = true;
    }

    function openRecord(record) {
      clearViewer();
      // Fast path: use the File object directly as a Blob URL
      try {
        const url = URL.createObjectURL(record.file);
        state.activeObjectUrl = url;
        state.activeBlobUrlForNewTab = url;
        el.viewerFrame.src = url;
        el.openNewTabBtn.disabled = false;
        el.fullscreenBtn.disabled = false;
      } catch (e) {
        // fallback: srcdoc
        record.file.text().then(html => {
          clearViewer();
          el.viewerFrame.srcdoc = html;
          state.activeBlobUrlForNewTab = null;
          el.openNewTabBtn.disabled = true;
          el.fullscreenBtn.disabled = false;
        }).catch(err => {
          clearViewer();
          setStatus(`讀取檔案失敗：${err?.message || err}`, 'error');
        });
      }
    }

    function openActive() {
      if (state.activeIndex < 0 || state.activeIndex >= state.filtered.length) return;
      const r = state.filtered[state.activeIndex];
      openRecord(r);
      // highlight list
      highlightActiveInList();
      updateTopStatus();
    }

    function highlightActiveInList() {
      const nodes = el.listItems.querySelectorAll('.item');
      nodes.forEach(n => n.classList.remove('active'));
      const active = el.listItems.querySelector(`.item[data-idx="${state.activeIndex}"]`);
      if (active) active.classList.add('active');
    }

    function setActiveIndex(idx, { scrollIntoView = false } = {}) {
      if (state.filtered.length === 0) return;
      state.activeIndex = ((idx % state.filtered.length) + state.filtered.length) % state.filtered.length;
      openActive();
      renderList();
      if (scrollIntoView) {
        const node = el.listItems.querySelector(`.item[data-idx="${state.activeIndex}"]`);
        node?.scrollIntoView({ block: 'nearest' });
      }
    }

    function clearAll() {
      state.files = [];
      state.filtered = [];
      state.activeIndex = -1;
      state.folderDisplayName = "";
      el.folderLabel.textContent = '尚未選擇資料夾';
      fillSelect(el.dateSel, [], { includeAll: true, allLabel: "All" });
      fillSelect(el.tickerSel, [], { includeAll: true, allLabel: "All" });
      fillSelect(el.featureSel, [], { includeAll: true, allLabel: "All" });
      el.searchTxt.value = '';
      el.listItems.innerHTML = `<div class="hint">請按「選擇資料夾」。</div>`;
      el.countPill.textContent = '0';
      clearViewer();
      setStatus('請先按「選擇資料夾」載入 HTML 存檔。', 'info');
    }

    // -----------------------------
    // Persistence: remember folder (when supported)
    // -----------------------------
    const idb = {
      db: null,
      async open() {
        if (this.db) return this.db;
        this.db = await new Promise((resolve, reject) => {
          const req = indexedDB.open('gex_viewer', 1);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains('kv')) db.createObjectStore('kv');
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
        return this.db;
      },
      async get(key) {
        const db = await this.open();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction('kv', 'readonly');
          const store = tx.objectStore('kv');
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result ?? null);
          req.onerror = () => reject(req.error);
        });
      },
      async set(key, val) {
        const db = await this.open();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction('kv', 'readwrite');
          const store = tx.objectStore('kv');
          const req = store.put(val, key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      },
      async del(key) {
        const db = await this.open();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction('kv', 'readwrite');
          const store = tx.objectStore('kv');
          const req = store.delete(key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      }
    };

    async function canUseDirectoryHandle() {
      return typeof window.showDirectoryPicker === 'function' && typeof FileSystemDirectoryHandle !== 'undefined';
    }

    async function tryAutoReconnectOnLoad() {
      // Only possible if browser supports directory handles and the page is in a context that allows it.
      try {
        if (!(await canUseDirectoryHandle())) return;
        const saved = await idb.get('lastDirHandle');
        if (!saved) return;

        // If permission already granted, we can auto-scan without a click.
        const perm = await saved.queryPermission?.({ mode: 'read' });
        el.reconnectBtn.disabled = false;
        el.forgetBtn.disabled = false;
        el.folderLabel.textContent = saved.name ? `已記住：${saved.name}` : '已記住資料夾';

        if (perm === 'granted') {
          await scanDirectoryHandle(saved);
        } else {
          setStatus('已記住資料夾；按「重新連線」即可載入（不會上傳）。', 'info');
        }
      } catch {
        // ignore
      }
    }

    async function forgetSavedFolder() {
      try {
        await idb.del('lastDirHandle');
      } catch {
        // ignore
      }
      el.reconnectBtn.disabled = true;
      el.forgetBtn.disabled = true;
      setStatus('已清除記住的資料夾。', 'ok');
    }

    async function scanDirectoryHandle(dirHandle) {
      clearAll();
      state.folderDisplayName = dirHandle?.name || '(資料夾)';
      el.folderLabel.textContent = state.folderDisplayName;

      const records = [];
      let skipped = 0;

      async function walk(handle, prefix) {
        for await (const entry of handle.values()) {
          if (entry.kind === 'directory') {
            await walk(entry, `${prefix}${entry.name}/`);
          } else if (entry.kind === 'file') {
            if (!entry.name.toLowerCase().endsWith('.html')) { skipped++; continue; }
            const file = await entry.getFile();
            const relPath = `${prefix}${entry.name}`;
            const rec = parseRecordFromFileLike({ file, relPath, name: entry.name });
            if (!rec) { skipped++; continue; }
            records.push(rec);
          }
        }
      }

      await walk(dirHandle, `${state.folderDisplayName}/`);

      if (records.length === 0) {
        setStatus('找不到符合命名規則的 .html。請確認檔名格式：yyyy-mm-dd_時間_ticker_功能.html', 'error');
        return;
      }

      state.files = records.sort((a, b) => a.ts - b.ts || a.relPath.localeCompare(b.relPath));

      fillSelect(el.dateSel, Array.from(new Set(state.files.map(r => r.date))).sort(), { includeAll: true, allLabel: "All" });
      fillSelect(el.tickerSel, Array.from(new Set(state.files.map(r => r.ticker))).sort(), { includeAll: true, allLabel: "All" });
      fillSelect(el.featureSel, Array.from(new Set(state.files.map(r => r.feature))).sort(), { includeAll: true, allLabel: "All" });
      el.dateSel.value = "__ALL__";
      el.tickerSel.value = "__ALL__";
      el.featureSel.value = "__ALL__";

      state.filtered = getFiltered(state.files);
      state.activeIndex = 0;
      openActive();
      renderList();
      updateTopStatus();

      setStatus(`載入 ${state.files.length} 個 HTML（略過 ${skipped} 個不符合規則/非 HTML）。`, 'ok');
    }

    async function scanFiles(fileList) {
      clearAll();
      const files = Array.from(fileList || []);
      if (files.length === 0) {
        setStatus('你沒有選到任何檔案。', 'error');
        return;
      }

      // Derive folder display name from first file's relative path
      const rp = files[0].webkitRelativePath || "";
      state.folderDisplayName = rp ? rp.split('/')[0] : "(已選取)";
      el.folderLabel.textContent = state.folderDisplayName;

      const records = [];
      let skipped = 0;
      for (const f of files) {
        if (!f.name.toLowerCase().endsWith('.html')) { skipped++; continue; }
        const relPath = f.webkitRelativePath || f.name;
        const rec = parseRecordFromFileLike({ file: f, relPath, name: f.name });
        if (!rec) { skipped++; continue; }
        records.push(rec);
      }

      if (records.length === 0) {
        setStatus('找不到符合命名規則的 .html。請確認檔名格式：yyyy-mm-dd_時間_ticker_功能.html', 'error');
        return;
      }

      state.files = records.sort((a, b) => a.ts - b.ts || a.relPath.localeCompare(b.relPath));

      // Fill filters (initially All)
      fillSelect(el.dateSel, Array.from(new Set(state.files.map(r => r.date))).sort(), { includeAll: true, allLabel: "All" });
      fillSelect(el.tickerSel, Array.from(new Set(state.files.map(r => r.ticker))).sort(), { includeAll: true, allLabel: "All" });
      fillSelect(el.featureSel, Array.from(new Set(state.files.map(r => r.feature))).sort(), { includeAll: true, allLabel: "All" });
      el.dateSel.value = "__ALL__";
      el.tickerSel.value = "__ALL__";
      el.featureSel.value = "__ALL__";

      state.filtered = getFiltered(state.files);
      state.activeIndex = 0;
      openActive();
      renderList();
      updateTopStatus();

      const msg = `載入 ${state.files.length} 個 HTML（略過 ${skipped} 個不符合規則/非 HTML）。`;
      setStatus(msg, 'ok');
    }

    // -----------------------------
    // Events
    // -----------------------------
    el.pickFolderBtn.addEventListener('click', async () => {
      // Prefer true directory handle (can be remembered). If not available or blocked, fallback to webkitdirectory input.
      try {
        if (await canUseDirectoryHandle()) {
          const handle = await window.showDirectoryPicker({ mode: 'read' });
          try {
            await idb.set('lastDirHandle', handle);
            el.reconnectBtn.disabled = false;
            el.forgetBtn.disabled = false;
          } catch {
            // If persisting handle fails, continue without persistence.
          }
          await scanDirectoryHandle(handle);
          return;
        }
      } catch (e) {
        // Likely blocked in non-secure context (file://). We'll fallback to webkitdirectory.
        setStatus('此環境無法使用「記住資料夾」；改用本機選取（不會上傳）。', 'info');
      }
      el.dirInput.click();
    });
    el.dirInput.addEventListener('change', (e) => scanFiles(e.target.files));

    el.clearBtn.addEventListener('click', () => clearAll());
    el.reconnectBtn.addEventListener('click', async () => {
      try {
        const saved = await idb.get('lastDirHandle');
        if (!saved) {
          setStatus('尚未記住任何資料夾。', 'info');
          return;
        }
        // Request permission requires user gesture (this click).
        const perm = await saved.requestPermission?.({ mode: 'read' });
        if (perm !== 'granted') {
          setStatus('未授權讀取資料夾。', 'error');
          return;
        }
        await scanDirectoryHandle(saved);
      } catch (e) {
        setStatus(`重新連線失敗：${e?.message || e}`, 'error');
      }
    });
    el.forgetBtn.addEventListener('click', () => forgetSavedFolder());
    el.searchTxt.addEventListener('input', () => rebuildFiltersAndView());
    el.dateSel.addEventListener('change', () => rebuildFiltersAndView());
    el.tickerSel.addEventListener('change', () => rebuildFiltersAndView());
    el.featureSel.addEventListener('change', () => rebuildFiltersAndView());

    el.listItems.addEventListener('click', (e) => {
      const item = e.target.closest('.item');
      if (!item) return;
      const idx = Number(item.dataset.idx);
      if (!Number.isFinite(idx)) return;
      setActiveIndex(idx, { scrollIntoView: false });
    });

    function setSidebarCollapsed(collapsed) {
      if (collapsed) document.body.classList.add('sidebarCollapsed');
      else document.body.classList.remove('sidebarCollapsed');
      el.toggleSidebarBtn.textContent = collapsed ? '展開側欄' : '收合側欄';
    }

    el.collapseBtn.addEventListener('click', () => setSidebarCollapsed(true));
    el.toggleSidebarBtn.addEventListener('click', () => {
      const collapsed = document.body.classList.contains('sidebarCollapsed');
      setSidebarCollapsed(!collapsed);
    });

    el.fullscreenBtn.addEventListener('click', async () => {
      const target = document.getElementById('mainPanel');
      try {
        if (!document.fullscreenElement) await target.requestFullscreen();
        else await document.exitFullscreen();
      } catch (e) {
        setStatus(`全螢幕失敗：${e?.message || e}`, 'error');
      }
    });

    el.openNewTabBtn.addEventListener('click', () => {
      if (!state.activeBlobUrlForNewTab) return;
      window.open(state.activeBlobUrlForNewTab, '_blank', 'noopener,noreferrer');
    });

    document.addEventListener('keydown', (e) => {
      if (isTypingContext()) return;
      if (state.filtered.length === 0) return;

      // Up/Down: navigate within the SAME ticker only (sorted by date+time)
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        e.preventDefault();
        const currRecord = state.filtered[state.activeIndex];
        if (!currRecord) return;

        // Build a subset of filtered items with the same ticker, sorted by ts
        const sameTicker = state.filtered
          .map((r, idx) => ({ r, idx }))
          .filter(x => x.r.ticker === currRecord.ticker);
        if (sameTicker.length === 0) return;

        // Find current position in this subset
        const posInSubset = sameTicker.findIndex(x => x.idx === state.activeIndex);
        if (posInSubset === -1) return;

        // Move within subset (with wrap-around)
        const dir = e.key === 'ArrowUp' ? -1 : 1;
        const nextPosInSubset = (posInSubset + dir + sameTicker.length) % sameTicker.length;
        const nextGlobalIdx = sameTicker[nextPosInSubset].idx;

        setActiveIndex(nextGlobalIdx, { scrollIntoView: true });
        return;
      }

      // Left/Right: cycle through features (requires ticker selected or uses current active ticker)
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
        const currRecord = state.filtered[state.activeIndex];
        if (!currRecord) return;

        // Use current record's ticker for feature cycling
        const targetTicker = currRecord.ticker;

        // Get all features available for this ticker (respecting date filter)
        const f = activeFilters();
        const features = [];
        const seen = new Set();
        for (const r of state.files) {
          if (r.ticker !== targetTicker) continue;
          if (f.date !== "__ALL__" && r.date !== f.date) continue;
          if (!seen.has(r.feature)) {
            seen.add(r.feature);
            features.push(r.feature);
          }
        }
        features.sort((a, b) => a.localeCompare(b));
        if (features.length === 0) return;

        const currFeature = currRecord.feature;
        const currIdx = features.indexOf(currFeature);

        const dir = (e.key === 'ArrowLeft') ? -1 : 1;
        const nextIdx = currIdx === -1 ? 0 : (currIdx + dir + features.length) % features.length;
        const nextFeature = features[nextIdx];

        // Keep ts to find nearest item after filter change
        const keepTs = currRecord.ts;

        // Update feature filter (set to specific feature, not All)
        el.featureSel.value = nextFeature;

        // Also ensure ticker filter matches the current ticker (so filtered list is correct)
        el.tickerSel.value = targetTicker;

        // Rebuild and find closest item
        rebuildFiltersAndView({ keepNearestToTs: keepTs });

        // Make sure active item visible
        const node = el.listItems.querySelector(`.item[data-idx="${state.activeIndex}"]`);
        node?.scrollIntoView({ block: 'nearest' });
      }
    });

    // Init
    clearAll();
    tryAutoReconnectOnLoad();
  </script>
</body>
</html>

